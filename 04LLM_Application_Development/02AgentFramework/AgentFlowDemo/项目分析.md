## Agent后端设计

### 1、当前设计

系统架构：

```
┌─────────────┐      WebSocket       ┌──────────────┐      HTTP/SSE      ┌─────────────────┐
│             │ ◄──────────────────► │              │ ◄────────────────► │                 │
│  Vue.js     │                      │   Golang     │                    │  Python Agent   │
│  Frontend   │                      │   Backend    │                    │  (LangGraph)    │
│             │                      │   (Gin)      │                    │                 │
└─────────────┘                      └──────────────┘                    └─────────────────┘
                                            │                                     │
                                            │                                     │
                                            ▼                                     ▼
                                      Session 管理                          MCP 工具集成
```

Agent 三大核心组件：

1. 模型服务（LLM Service）：基于vllm/OpenRouter等提供，通过 LangChain 的 ChatOpenAI 进行封装

2. 基于 LangGraph 的 Agent 设计：略

3. Golang 后端设计：

   - Golang 后端使用 Gin 框架，作为会话管理层和协议转换层

   - 核心职责：

     - WebSocket 连接管理（多用户并发会话）

     - 协议转换（WebSocket ↔ HTTP/SSE）

     - 会话状态维护

三者的通信架构图（MCP处存疑）：

```
┌─────────┐   WebSocket    ┌──────────┐    HTTP/SSE     ┌─────────────┐    JSON-RPC    ┌───────────┐
│ 前端    │ ◄────────────► │ Golang   │ ◄─────────────► │ Agent       │ ◄───────────► │ MCP Server│
│ Vue.js  │                │ Backend  │                 │ (FastAPI)   │               │           │
└─────────┘                └──────────┘                 └─────────────┘               └───────────┘
                                                               │
                                                               ▼
                                                        ┌─────────────┐
                                                        │ OpenRouter  │
                                                        │ (LLM API)   │
                                                        └─────────────┘
```

为什么采用这种分层设计？

- 职责分离：
  - Golang 后端专注于连接管理、会话状态、并发控制
  - Python Agent 专注于 AI 推理、工具编排
  - 各服务可独立扩展和部署
- 协议转换：
  - 前端使用 WebSocket 获得最佳实时体验
  - 后端使用 SSE 简化流式数据处理（无需维护 WebSocket 状态）
- 技术选型优势：
  - Golang：高并发、低内存占用，适合处理大量 WebSocket 连接
  - Python：AI/ML 生态丰富，LangGraph/LangChain 支持完善



### 2、维护方法

#### 问题 1：WebSocket 连接中断

现象：客户端显示断开连接

排查：

```
# 检查 Golang 后端日志
grep "WebSocket" /var/log/backend.log

# 常见原因
1. 心跳超时（默认 60 秒）
2. Nginx 代理超时
```

解决：

```
// 调整心跳间隔
ticker := time.NewTicker(30 * time.Second)  // 更频繁的心跳
```



#### 问题 2：SSE 流式传输中断

现象：响应不完整或卡住

排查：

```
// 当前代码中的潜在问题
case session.Send <- msg:
    return nil
default:
    return nil // 通道满,跳过 ← 可能丢失消息
```

解决：增加通道缓冲区或使用阻塞发送



#### 问题 3：MCP 工具加载失败

现象：工具调用返回"工具不可用"

排查：

```
# 检查 MCP Server 状态
curl http://localhost:8006/mcp_demo -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}'
```



#### 问题 4：LLM 响应慢

维护方法：

- 监控 OpenRouter 响应时间

- 设置合理超时

- 考虑缓存常见查询结果





### 3、优化建议

1）架构层面

| 优化项     | 当前状态   | 优化方向                         |
| :--------- | :--------- | :------------------------------- |
| 会话持久化 | 内存 Map   | Redis 存储，支持分布式部署       |
| 消息历史   | 无持久化   | 接入数据库（PostgreSQL/MongoDB） |
| 服务发现   | 硬编码 URL | 引入服务注册（Consul/Nacos）     |
| 负载均衡   | 无         | Agent 服务水平扩展 + 负载均衡    |

2）性能优化

```
// 当前：每次请求创建新 HTTP 客户端
client:  &http.Client{},

// 优化：复用连接 + 连接池
client: &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 20,
        IdleConnTimeout:     90 * time.Second,
    },
    Timeout: 30 * time.Second,
},
```

3）可靠性优化

- 重试机制：Agent 服务调用失败时自动重试

- 熔断器：防止级联故障

- 限流：保护后端服务

- 监控告警：Prometheus + Grafana



## 异步相关设计

### 1、Python Agent 服务（asyncio）

| 位置               | 异步操作                               | 作用              |
| :----------------- | :------------------------------------- | :---------------- |
| mcp_agent.py       | async def stream_chat()                | 流式生成响应      |
| mcp_agent.py       | async for chunk in self.llm.astream()  | 流式接收 LLM 输出 |
| mcp_http_client.py | httpx.AsyncClient                      | 异步 HTTP 请求    |
| main.py            | EventSourceResponse(event_generator()) | SSE 异步生成器    |

```
# 核心异步流程
async def stream_chat(self, message: str, session_id: str):
    # 异步分析意图
    state = await self._analyze_intent(initial_state)
    
    # 异步调用工具
    if state["current_step"] == "use_tool":
        state = await self._call_tool(state)
    
    # 异步流式输出
    async for chunk in self.llm.astream(context_messages):
        yield chunk.content
```



### 2、Golang 后端（goroutine）

| 位置            | 并发操作                                  | 作用                 |
| :-------------- | :---------------------------------------- | :------------------- |
| chat_handler.go | go h.readPump(session)                    | 异步读取客户端消息   |
| chat_handler.go | go h.writePump(session)                   | 异步发送消息到客户端 |
| chat_handler.go | go h.handleChatRequest(session, &chatReq) | 异步处理聊天请求     |

```
// 每个 WebSocket 连接启动两个 goroutine
go h.readPump(session)   // 读协程：处理客户端消息
go h.writePump(session)  // 写协程：发送响应消息

// 使用 channel 进行协程间通信
session.Send <- msg  // 非阻塞发送到写协程
```

异步编程的价值：

- 高并发：单个 Golang 进程可处理数万 WebSocket 连接

- 非阻塞 I/O：等待 LLM 响应时不阻塞其他请求

- 流式体验：边生成边发送，降低用户感知延迟



## WebSocket

为什么要使用WebSocket，对于此类实时聊天类的产品，Socket.IO是否更合适？

| 特性            | 原生 WebSocket              | Socket.IO                           |
| :-------------- | :-------------------------- | :---------------------------------- |
| 协议            | W3C 标准协议                | 自定义协议（基于 WebSocket + 轮询） |
| 浏览器支持      | 现代浏览器原生支持          | 需引入客户端库（~40KB）             |
| 自动重连        | ❌ 需手动实现                | ✅ 内置                              |
| 心跳检测        | ❌ 需手动实现                | ✅ 内置                              |
| 房间/命名空间   | ❌ 需手动实现                | ✅ 内置                              |
| 消息确认（ACK） | ❌ 需手动实现                | ✅ 内置                              |
| 二进制支持      | ✅ 原生支持                  | ✅ 支持                              |
| 降级机制        | ❌ 无                        | ✅ 自动降级到轮询                    |
| 跨语言生态      | ✅ 任意语言库                | ⚠️ 服务端库有限                      |
| Golang 支持     | ✅ gorilla/websocket（成熟） | ⚠️ go-socket.io（维护一般）          |
| 性能开销        | 最低                        | 较高（协议解析开销）                |

忽略项目现有代码，从宏观角度分析：

| 产品阶段     | 推荐方案                  | 理由                          |
| :----------- | :------------------------ | :---------------------------- |
| MVP/早期     | WebSocket                 | 简单、性能好、Golang 生态成熟 |
| 多设备同步   | WebSocket + Redis Pub/Sub | 自建广播，保持技术栈统一      |
| 复杂实时协作 | Socket.IO（需 Node.js）   | 房间/命名空间功能完善         |

WebSocket + Redis Pub/Sub 方案：

```
┌──────────┐      ┌──────────┐      ┌──────────┐
│ 用户A    │      │ 用户A    │      │ 用户B    │
│ 手机     │      │ 电脑     │      │ 手机     │
└────┬─────┘      └────┬─────┘      └────┬─────┘
     │                 │                 │
     │ WebSocket       │ WebSocket       │ WebSocket
     │                 │                 │
     ▼                 ▼                 ▼
┌─────────────────────────────────────────────────┐
│              Golang 后端集群                     │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐     │
│  │ 实例 1  │    │ 实例 2  │    │ 实例 3  │     │
│  └────┬────┘    └────┬────┘    └────┬────┘     │
│       │              │              │          │
│       └──────────────┼──────────────┘          │
│                      ▼                         │
│              ┌─────────────┐                   │
│              │   Redis     │                   │
│              │  Pub/Sub    │                   │
│              └─────────────┘                   │
└─────────────────────────────────────────────────┘
```

总结：

| 问题                   | 答案                          |
| :--------------------- | :---------------------------- |
| 多用户场景用什么？     | 仍然推荐 WebSocket            |
| 多设备同步怎么办？     | WebSocket + Redis Pub/Sub     |
| 什么时候用 Socket.IO？ | 复杂实时协作 + 团队用 Node.js |
| Golang 能实现吗？      | 完全可以，且性能更好          |



面向多用户、多历史对话的场景下，项目架构图设计：

```
                                    ┌─────────────────────────────────────────┐
                                    │              负载均衡 (Nginx)            │
                                    └─────────────────────────────────────────┘
                                                       │
                    ┌──────────────────────────────────┼──────────────────────────────────┐
                    │                                  │                                  │
                    ▼                                  ▼                                  ▼
           ┌─────────────────┐              ┌─────────────────┐              ┌─────────────────┐
           │  Golang 后端 1   │              │  Golang 后端 2   │              │  Golang 后端 N   │
           │  (WebSocket)    │              │  (WebSocket)    │              │  (WebSocket)    │
           └────────┬────────┘              └────────┬────────┘              └────────┬────────┘
                    │                                │                                │
                    └────────────────────────────────┼────────────────────────────────┘
                                                     │
                    ┌────────────────────────────────┼────────────────────────────────┐
                    │                                │                                │
                    ▼                                ▼                                ▼
           ┌─────────────────┐              ┌─────────────────┐              ┌─────────────────┐
           │     Redis       │              │   PostgreSQL    │              │  Agent Service  │
           │  (会话/缓存)     │              │   (持久化)       │              │   (LangGraph)   │
           └─────────────────┘              └─────────────────┘              └─────────────────┘
```



## 项目设计相关

不管是架构还是项目目录设计，可以参考OpenManus（早期版本）等开源项目
